// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StaticData.proto

#ifndef PROTOBUF_StaticData_2eproto__INCLUDED
#define PROTOBUF_StaticData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "NameData.pb.h"
// @@protoc_insertion_point(includes)

namespace fantasybit {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_StaticData_2eproto();
void protobuf_AssignDesc_StaticData_2eproto();
void protobuf_ShutdownFile_StaticData_2eproto();

class PlayerBase;
class GameInfo;
class WeeklySchedule;
class Kstats;
class Dstats;
class Ostats;
class Stats;
class PlayerResult;
class GameResult;

// ===================================================================

class PlayerBase : public ::google::protobuf::Message {
 public:
  PlayerBase();
  virtual ~PlayerBase();

  PlayerBase(const PlayerBase& from);

  inline PlayerBase& operator=(const PlayerBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerBase& default_instance();

  void Swap(PlayerBase* other);

  // implements Message ----------------------------------------------

  PlayerBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerBase& from);
  void MergeFrom(const PlayerBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string first = 30;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 30;
  inline const ::std::string& first() const;
  inline void set_first(const ::std::string& value);
  inline void set_first(const char* value);
  inline void set_first(const char* value, size_t size);
  inline ::std::string* mutable_first();
  inline ::std::string* release_first();
  inline void set_allocated_first(::std::string* first);

  // optional string last = 40;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 40;
  inline const ::std::string& last() const;
  inline void set_last(const ::std::string& value);
  inline void set_last(const char* value);
  inline void set_last(const char* value, size_t size);
  inline ::std::string* mutable_last();
  inline ::std::string* release_last();
  inline void set_allocated_last(::std::string* last);

  // optional string position = 50;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 50;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerBase)
 private:
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* first_;
  ::std::string* last_;
  ::std::string* position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static PlayerBase* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  GameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 10;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 10;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string home = 20;
  inline bool has_home() const;
  inline void clear_home();
  static const int kHomeFieldNumber = 20;
  inline const ::std::string& home() const;
  inline void set_home(const ::std::string& value);
  inline void set_home(const char* value);
  inline void set_home(const char* value, size_t size);
  inline ::std::string* mutable_home();
  inline ::std::string* release_home();
  inline void set_allocated_home(::std::string* home);

  // optional string away = 30;
  inline bool has_away() const;
  inline void clear_away();
  static const int kAwayFieldNumber = 30;
  inline const ::std::string& away() const;
  inline void set_away(const ::std::string& value);
  inline void set_away(const char* value);
  inline void set_away(const char* value, size_t size);
  inline ::std::string* mutable_away();
  inline ::std::string* release_away();
  inline void set_allocated_away(::std::string* away);

  // optional uint32 time = 40;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 40;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.GameInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_home();
  inline void clear_has_home();
  inline void set_has_away();
  inline void clear_has_away();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* home_;
  ::std::string* away_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class WeeklySchedule : public ::google::protobuf::Message {
 public:
  WeeklySchedule();
  virtual ~WeeklySchedule();

  WeeklySchedule(const WeeklySchedule& from);

  inline WeeklySchedule& operator=(const WeeklySchedule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeeklySchedule& default_instance();

  void Swap(WeeklySchedule* other);

  // implements Message ----------------------------------------------

  WeeklySchedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeeklySchedule& from);
  void MergeFrom(const WeeklySchedule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fantasybit.GameInfo games = 10;
  inline int games_size() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 10;
  inline const ::fantasybit::GameInfo& games(int index) const;
  inline ::fantasybit::GameInfo* mutable_games(int index);
  inline ::fantasybit::GameInfo* add_games();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::GameInfo >&
      games() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::GameInfo >*
      mutable_games();

  // repeated string byes = 20;
  inline int byes_size() const;
  inline void clear_byes();
  static const int kByesFieldNumber = 20;
  inline const ::std::string& byes(int index) const;
  inline ::std::string* mutable_byes(int index);
  inline void set_byes(int index, const ::std::string& value);
  inline void set_byes(int index, const char* value);
  inline void set_byes(int index, const char* value, size_t size);
  inline ::std::string* add_byes();
  inline void add_byes(const ::std::string& value);
  inline void add_byes(const char* value);
  inline void add_byes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& byes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_byes();

  // @@protoc_insertion_point(class_scope:fantasybit.WeeklySchedule)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fantasybit::GameInfo > games_;
  ::google::protobuf::RepeatedPtrField< ::std::string> byes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static WeeklySchedule* default_instance_;
};
// -------------------------------------------------------------------

class Kstats : public ::google::protobuf::Message {
 public:
  Kstats();
  virtual ~Kstats();

  Kstats(const Kstats& from);

  inline Kstats& operator=(const Kstats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Kstats& default_instance();

  void Swap(Kstats* other);

  // implements Message ----------------------------------------------

  Kstats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Kstats& from);
  void MergeFrom(const Kstats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pa = 10;
  inline bool has_pa() const;
  inline void clear_pa();
  static const int kPaFieldNumber = 10;
  inline ::google::protobuf::int32 pa() const;
  inline void set_pa(::google::protobuf::int32 value);

  // repeated int32 fg = 20;
  inline int fg_size() const;
  inline void clear_fg();
  static const int kFgFieldNumber = 20;
  inline ::google::protobuf::int32 fg(int index) const;
  inline void set_fg(int index, ::google::protobuf::int32 value);
  inline void add_fg(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      fg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_fg();

  // @@protoc_insertion_point(class_scope:fantasybit.Kstats)
 private:
  inline void set_has_pa();
  inline void clear_has_pa();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > fg_;
  ::google::protobuf::int32 pa_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static Kstats* default_instance_;
};
// -------------------------------------------------------------------

class Dstats : public ::google::protobuf::Message {
 public:
  Dstats();
  virtual ~Dstats();

  Dstats(const Dstats& from);

  inline Dstats& operator=(const Dstats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Dstats& default_instance();

  void Swap(Dstats* other);

  // implements Message ----------------------------------------------

  Dstats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Dstats& from);
  void MergeFrom(const Dstats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 twopt = 100;
  inline bool has_twopt() const;
  inline void clear_twopt();
  static const int kTwoptFieldNumber = 100;
  inline ::google::protobuf::int32 twopt() const;
  inline void set_twopt(::google::protobuf::int32 value);

  // optional int32 onept = 110;
  inline bool has_onept() const;
  inline void clear_onept();
  static const int kOneptFieldNumber = 110;
  inline ::google::protobuf::int32 onept() const;
  inline void set_onept(::google::protobuf::int32 value);

  // optional int32 deftd = 120;
  inline bool has_deftd() const;
  inline void clear_deftd();
  static const int kDeftdFieldNumber = 120;
  inline ::google::protobuf::int32 deftd() const;
  inline void set_deftd(::google::protobuf::int32 value);

  // optional int32 sfty = 130;
  inline bool has_sfty() const;
  inline void clear_sfty();
  static const int kSftyFieldNumber = 130;
  inline ::google::protobuf::int32 sfty() const;
  inline void set_sfty(::google::protobuf::int32 value);

  // optional int32 turnovers = 140;
  inline bool has_turnovers() const;
  inline void clear_turnovers();
  static const int kTurnoversFieldNumber = 140;
  inline ::google::protobuf::int32 turnovers() const;
  inline void set_turnovers(::google::protobuf::int32 value);

  // optional int32 sacks = 150;
  inline bool has_sacks() const;
  inline void clear_sacks();
  static const int kSacksFieldNumber = 150;
  inline ::google::protobuf::int32 sacks() const;
  inline void set_sacks(::google::protobuf::int32 value);

  // optional int32 ptsa = 160;
  inline bool has_ptsa() const;
  inline void clear_ptsa();
  static const int kPtsaFieldNumber = 160;
  inline ::google::protobuf::int32 ptsa() const;
  inline void set_ptsa(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.Dstats)
 private:
  inline void set_has_twopt();
  inline void clear_has_twopt();
  inline void set_has_onept();
  inline void clear_has_onept();
  inline void set_has_deftd();
  inline void clear_has_deftd();
  inline void set_has_sfty();
  inline void clear_has_sfty();
  inline void set_has_turnovers();
  inline void clear_has_turnovers();
  inline void set_has_sacks();
  inline void clear_has_sacks();
  inline void set_has_ptsa();
  inline void clear_has_ptsa();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 twopt_;
  ::google::protobuf::int32 onept_;
  ::google::protobuf::int32 deftd_;
  ::google::protobuf::int32 sfty_;
  ::google::protobuf::int32 turnovers_;
  ::google::protobuf::int32 sacks_;
  ::google::protobuf::int32 ptsa_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static Dstats* default_instance_;
};
// -------------------------------------------------------------------

class Ostats : public ::google::protobuf::Message {
 public:
  Ostats();
  virtual ~Ostats();

  Ostats(const Ostats& from);

  inline Ostats& operator=(const Ostats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ostats& default_instance();

  void Swap(Ostats* other);

  // implements Message ----------------------------------------------

  Ostats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ostats& from);
  void MergeFrom(const Ostats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 passyds = 10;
  inline bool has_passyds() const;
  inline void clear_passyds();
  static const int kPassydsFieldNumber = 10;
  inline ::google::protobuf::int32 passyds() const;
  inline void set_passyds(::google::protobuf::int32 value);

  // optional int32 passtd = 20;
  inline bool has_passtd() const;
  inline void clear_passtd();
  static const int kPasstdFieldNumber = 20;
  inline ::google::protobuf::int32 passtd() const;
  inline void set_passtd(::google::protobuf::int32 value);

  // optional int32 rushyds = 30;
  inline bool has_rushyds() const;
  inline void clear_rushyds();
  static const int kRushydsFieldNumber = 30;
  inline ::google::protobuf::int32 rushyds() const;
  inline void set_rushyds(::google::protobuf::int32 value);

  // optional int32 rushtd = 40;
  inline bool has_rushtd() const;
  inline void clear_rushtd();
  static const int kRushtdFieldNumber = 40;
  inline ::google::protobuf::int32 rushtd() const;
  inline void set_rushtd(::google::protobuf::int32 value);

  // optional int32 recyds = 50;
  inline bool has_recyds() const;
  inline void clear_recyds();
  static const int kRecydsFieldNumber = 50;
  inline ::google::protobuf::int32 recyds() const;
  inline void set_recyds(::google::protobuf::int32 value);

  // optional int32 rectd = 60;
  inline bool has_rectd() const;
  inline void clear_rectd();
  static const int kRectdFieldNumber = 60;
  inline ::google::protobuf::int32 rectd() const;
  inline void set_rectd(::google::protobuf::int32 value);

  // optional int32 rec = 70;
  inline bool has_rec() const;
  inline void clear_rec();
  static const int kRecFieldNumber = 70;
  inline ::google::protobuf::int32 rec() const;
  inline void set_rec(::google::protobuf::int32 value);

  // optional int32 pint = 80;
  inline bool has_pint() const;
  inline void clear_pint();
  static const int kPintFieldNumber = 80;
  inline ::google::protobuf::int32 pint() const;
  inline void set_pint(::google::protobuf::int32 value);

  // optional int32 fumble = 90;
  inline bool has_fumble() const;
  inline void clear_fumble();
  static const int kFumbleFieldNumber = 90;
  inline ::google::protobuf::int32 fumble() const;
  inline void set_fumble(::google::protobuf::int32 value);

  // optional int32 twopt = 100;
  inline bool has_twopt() const;
  inline void clear_twopt();
  static const int kTwoptFieldNumber = 100;
  inline ::google::protobuf::int32 twopt() const;
  inline void set_twopt(::google::protobuf::int32 value);

  // optional int32 onept = 110;
  inline bool has_onept() const;
  inline void clear_onept();
  static const int kOneptFieldNumber = 110;
  inline ::google::protobuf::int32 onept() const;
  inline void set_onept(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.Ostats)
 private:
  inline void set_has_passyds();
  inline void clear_has_passyds();
  inline void set_has_passtd();
  inline void clear_has_passtd();
  inline void set_has_rushyds();
  inline void clear_has_rushyds();
  inline void set_has_rushtd();
  inline void clear_has_rushtd();
  inline void set_has_recyds();
  inline void clear_has_recyds();
  inline void set_has_rectd();
  inline void clear_has_rectd();
  inline void set_has_rec();
  inline void clear_has_rec();
  inline void set_has_pint();
  inline void clear_has_pint();
  inline void set_has_fumble();
  inline void clear_has_fumble();
  inline void set_has_twopt();
  inline void clear_has_twopt();
  inline void set_has_onept();
  inline void clear_has_onept();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 passyds_;
  ::google::protobuf::int32 passtd_;
  ::google::protobuf::int32 rushyds_;
  ::google::protobuf::int32 rushtd_;
  ::google::protobuf::int32 recyds_;
  ::google::protobuf::int32 rectd_;
  ::google::protobuf::int32 rec_;
  ::google::protobuf::int32 pint_;
  ::google::protobuf::int32 fumble_;
  ::google::protobuf::int32 twopt_;
  ::google::protobuf::int32 onept_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static Ostats* default_instance_;
};
// -------------------------------------------------------------------

class Stats : public ::google::protobuf::Message {
 public:
  Stats();
  virtual ~Stats();

  Stats(const Stats& from);

  inline Stats& operator=(const Stats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stats& default_instance();

  void Swap(Stats* other);

  // implements Message ----------------------------------------------

  Stats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stats& from);
  void MergeFrom(const Stats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.Ostats ostats = 10;
  inline bool has_ostats() const;
  inline void clear_ostats();
  static const int kOstatsFieldNumber = 10;
  inline const ::fantasybit::Ostats& ostats() const;
  inline ::fantasybit::Ostats* mutable_ostats();
  inline ::fantasybit::Ostats* release_ostats();
  inline void set_allocated_ostats(::fantasybit::Ostats* ostats);

  // optional .fantasybit.Dstats dstats = 20;
  inline bool has_dstats() const;
  inline void clear_dstats();
  static const int kDstatsFieldNumber = 20;
  inline const ::fantasybit::Dstats& dstats() const;
  inline ::fantasybit::Dstats* mutable_dstats();
  inline ::fantasybit::Dstats* release_dstats();
  inline void set_allocated_dstats(::fantasybit::Dstats* dstats);

  // optional .fantasybit.Kstats kstats = 30;
  inline bool has_kstats() const;
  inline void clear_kstats();
  static const int kKstatsFieldNumber = 30;
  inline const ::fantasybit::Kstats& kstats() const;
  inline ::fantasybit::Kstats* mutable_kstats();
  inline ::fantasybit::Kstats* release_kstats();
  inline void set_allocated_kstats(::fantasybit::Kstats* kstats);

  // @@protoc_insertion_point(class_scope:fantasybit.Stats)
 private:
  inline void set_has_ostats();
  inline void clear_has_ostats();
  inline void set_has_dstats();
  inline void clear_has_dstats();
  inline void set_has_kstats();
  inline void clear_has_kstats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::Ostats* ostats_;
  ::fantasybit::Dstats* dstats_;
  ::fantasybit::Kstats* kstats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static Stats* default_instance_;
};
// -------------------------------------------------------------------

class PlayerResult : public ::google::protobuf::Message {
 public:
  PlayerResult();
  virtual ~PlayerResult();

  PlayerResult(const PlayerResult& from);

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerResult& default_instance();

  void Swap(PlayerResult* other);

  // implements Message ----------------------------------------------

  PlayerResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional float result = 40;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 40;
  inline float result() const;
  inline void set_result(float value);

  // optional .fantasybit.Stats stats = 50;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 50;
  inline const ::fantasybit::Stats& stats() const;
  inline ::fantasybit::Stats* mutable_stats();
  inline ::fantasybit::Stats* release_stats();
  inline void set_allocated_stats(::fantasybit::Stats* stats);

  // repeated .fantasybit.FantasyBitAward fantaybitaward = 60;
  inline int fantaybitaward_size() const;
  inline void clear_fantaybitaward();
  static const int kFantaybitawardFieldNumber = 60;
  inline const ::fantasybit::FantasyBitAward& fantaybitaward(int index) const;
  inline ::fantasybit::FantasyBitAward* mutable_fantaybitaward(int index);
  inline ::fantasybit::FantasyBitAward* add_fantaybitaward();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitAward >&
      fantaybitaward() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitAward >*
      mutable_fantaybitaward();

  // repeated .fantasybit.FantasyBitPnl fantasybitpnl = 70;
  inline int fantasybitpnl_size() const;
  inline void clear_fantasybitpnl();
  static const int kFantasybitpnlFieldNumber = 70;
  inline const ::fantasybit::FantasyBitPnl& fantasybitpnl(int index) const;
  inline ::fantasybit::FantasyBitPnl* mutable_fantasybitpnl(int index);
  inline ::fantasybit::FantasyBitPnl* add_fantasybitpnl();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitPnl >&
      fantasybitpnl() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitPnl >*
      mutable_fantasybitpnl();

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerResult)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_stats();
  inline void clear_has_stats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::fantasybit::Stats* stats_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitAward > fantaybitaward_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitPnl > fantasybitpnl_;
  float result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static PlayerResult* default_instance_;
};
// -------------------------------------------------------------------

class GameResult : public ::google::protobuf::Message {
 public:
  GameResult();
  virtual ~GameResult();

  GameResult(const GameResult& from);

  inline GameResult& operator=(const GameResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameResult& default_instance();

  void Swap(GameResult* other);

  // implements Message ----------------------------------------------

  GameResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameResult& from);
  void MergeFrom(const GameResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // repeated .fantasybit.PlayerResult home_result = 10;
  inline int home_result_size() const;
  inline void clear_home_result();
  static const int kHomeResultFieldNumber = 10;
  inline const ::fantasybit::PlayerResult& home_result(int index) const;
  inline ::fantasybit::PlayerResult* mutable_home_result(int index);
  inline ::fantasybit::PlayerResult* add_home_result();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >&
      home_result() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >*
      mutable_home_result();

  // repeated .fantasybit.PlayerResult away_result = 20;
  inline int away_result_size() const;
  inline void clear_away_result();
  static const int kAwayResultFieldNumber = 20;
  inline const ::fantasybit::PlayerResult& away_result(int index) const;
  inline ::fantasybit::PlayerResult* mutable_away_result(int index);
  inline ::fantasybit::PlayerResult* add_away_result();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >&
      away_result() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >*
      mutable_away_result();

  // optional uint32 kickofftime = 30;
  inline bool has_kickofftime() const;
  inline void clear_kickofftime();
  static const int kKickofftimeFieldNumber = 30;
  inline ::google::protobuf::uint32 kickofftime() const;
  inline void set_kickofftime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.GameResult)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_kickofftime();
  inline void clear_has_kickofftime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult > home_result_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult > away_result_;
  ::google::protobuf::uint32 kickofftime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StaticData_2eproto();
  friend void protobuf_AssignDesc_StaticData_2eproto();
  friend void protobuf_ShutdownFile_StaticData_2eproto();

  void InitAsDefaultInstance();
  static GameResult* default_instance_;
};
// ===================================================================


// ===================================================================

// PlayerBase

// optional string first = 30;
inline bool PlayerBase::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerBase::set_has_first() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerBase::clear_has_first() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerBase::clear_first() {
  if (first_ != &::google::protobuf::internal::kEmptyString) {
    first_->clear();
  }
  clear_has_first();
}
inline const ::std::string& PlayerBase::first() const {
  return *first_;
}
inline void PlayerBase::set_first(const ::std::string& value) {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  first_->assign(value);
}
inline void PlayerBase::set_first(const char* value) {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  first_->assign(value);
}
inline void PlayerBase::set_first(const char* value, size_t size) {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  first_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBase::mutable_first() {
  set_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    first_ = new ::std::string;
  }
  return first_;
}
inline ::std::string* PlayerBase::release_first() {
  clear_has_first();
  if (first_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_;
    first_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerBase::set_allocated_first(::std::string* first) {
  if (first_ != &::google::protobuf::internal::kEmptyString) {
    delete first_;
  }
  if (first) {
    set_has_first();
    first_ = first;
  } else {
    clear_has_first();
    first_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string last = 40;
inline bool PlayerBase::has_last() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerBase::set_has_last() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerBase::clear_has_last() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerBase::clear_last() {
  if (last_ != &::google::protobuf::internal::kEmptyString) {
    last_->clear();
  }
  clear_has_last();
}
inline const ::std::string& PlayerBase::last() const {
  return *last_;
}
inline void PlayerBase::set_last(const ::std::string& value) {
  set_has_last();
  if (last_ == &::google::protobuf::internal::kEmptyString) {
    last_ = new ::std::string;
  }
  last_->assign(value);
}
inline void PlayerBase::set_last(const char* value) {
  set_has_last();
  if (last_ == &::google::protobuf::internal::kEmptyString) {
    last_ = new ::std::string;
  }
  last_->assign(value);
}
inline void PlayerBase::set_last(const char* value, size_t size) {
  set_has_last();
  if (last_ == &::google::protobuf::internal::kEmptyString) {
    last_ = new ::std::string;
  }
  last_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBase::mutable_last() {
  set_has_last();
  if (last_ == &::google::protobuf::internal::kEmptyString) {
    last_ = new ::std::string;
  }
  return last_;
}
inline ::std::string* PlayerBase::release_last() {
  clear_has_last();
  if (last_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_;
    last_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerBase::set_allocated_last(::std::string* last) {
  if (last_ != &::google::protobuf::internal::kEmptyString) {
    delete last_;
  }
  if (last) {
    set_has_last();
    last_ = last;
  } else {
    clear_has_last();
    last_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string position = 50;
inline bool PlayerBase::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerBase::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerBase::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerBase::clear_position() {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& PlayerBase::position() const {
  return *position_;
}
inline void PlayerBase::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void PlayerBase::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void PlayerBase::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBase::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  return position_;
}
inline ::std::string* PlayerBase::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerBase::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameInfo

// optional string id = 10;
inline bool GameInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& GameInfo::id() const {
  return *id_;
}
inline void GameInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GameInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GameInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* GameInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string home = 20;
inline bool GameInfo::has_home() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_home() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_home() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_home() {
  if (home_ != &::google::protobuf::internal::kEmptyString) {
    home_->clear();
  }
  clear_has_home();
}
inline const ::std::string& GameInfo::home() const {
  return *home_;
}
inline void GameInfo::set_home(const ::std::string& value) {
  set_has_home();
  if (home_ == &::google::protobuf::internal::kEmptyString) {
    home_ = new ::std::string;
  }
  home_->assign(value);
}
inline void GameInfo::set_home(const char* value) {
  set_has_home();
  if (home_ == &::google::protobuf::internal::kEmptyString) {
    home_ = new ::std::string;
  }
  home_->assign(value);
}
inline void GameInfo::set_home(const char* value, size_t size) {
  set_has_home();
  if (home_ == &::google::protobuf::internal::kEmptyString) {
    home_ = new ::std::string;
  }
  home_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_home() {
  set_has_home();
  if (home_ == &::google::protobuf::internal::kEmptyString) {
    home_ = new ::std::string;
  }
  return home_;
}
inline ::std::string* GameInfo::release_home() {
  clear_has_home();
  if (home_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = home_;
    home_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_home(::std::string* home) {
  if (home_ != &::google::protobuf::internal::kEmptyString) {
    delete home_;
  }
  if (home) {
    set_has_home();
    home_ = home;
  } else {
    clear_has_home();
    home_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string away = 30;
inline bool GameInfo::has_away() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_away() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_away() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_away() {
  if (away_ != &::google::protobuf::internal::kEmptyString) {
    away_->clear();
  }
  clear_has_away();
}
inline const ::std::string& GameInfo::away() const {
  return *away_;
}
inline void GameInfo::set_away(const ::std::string& value) {
  set_has_away();
  if (away_ == &::google::protobuf::internal::kEmptyString) {
    away_ = new ::std::string;
  }
  away_->assign(value);
}
inline void GameInfo::set_away(const char* value) {
  set_has_away();
  if (away_ == &::google::protobuf::internal::kEmptyString) {
    away_ = new ::std::string;
  }
  away_->assign(value);
}
inline void GameInfo::set_away(const char* value, size_t size) {
  set_has_away();
  if (away_ == &::google::protobuf::internal::kEmptyString) {
    away_ = new ::std::string;
  }
  away_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_away() {
  set_has_away();
  if (away_ == &::google::protobuf::internal::kEmptyString) {
    away_ = new ::std::string;
  }
  return away_;
}
inline ::std::string* GameInfo::release_away() {
  clear_has_away();
  if (away_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = away_;
    away_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_away(::std::string* away) {
  if (away_ != &::google::protobuf::internal::kEmptyString) {
    delete away_;
  }
  if (away) {
    set_has_away();
    away_ = away;
  } else {
    clear_has_away();
    away_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 time = 40;
inline bool GameInfo::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 GameInfo::time() const {
  return time_;
}
inline void GameInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// WeeklySchedule

// repeated .fantasybit.GameInfo games = 10;
inline int WeeklySchedule::games_size() const {
  return games_.size();
}
inline void WeeklySchedule::clear_games() {
  games_.Clear();
}
inline const ::fantasybit::GameInfo& WeeklySchedule::games(int index) const {
  return games_.Get(index);
}
inline ::fantasybit::GameInfo* WeeklySchedule::mutable_games(int index) {
  return games_.Mutable(index);
}
inline ::fantasybit::GameInfo* WeeklySchedule::add_games() {
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::GameInfo >&
WeeklySchedule::games() const {
  return games_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::GameInfo >*
WeeklySchedule::mutable_games() {
  return &games_;
}

// repeated string byes = 20;
inline int WeeklySchedule::byes_size() const {
  return byes_.size();
}
inline void WeeklySchedule::clear_byes() {
  byes_.Clear();
}
inline const ::std::string& WeeklySchedule::byes(int index) const {
  return byes_.Get(index);
}
inline ::std::string* WeeklySchedule::mutable_byes(int index) {
  return byes_.Mutable(index);
}
inline void WeeklySchedule::set_byes(int index, const ::std::string& value) {
  byes_.Mutable(index)->assign(value);
}
inline void WeeklySchedule::set_byes(int index, const char* value) {
  byes_.Mutable(index)->assign(value);
}
inline void WeeklySchedule::set_byes(int index, const char* value, size_t size) {
  byes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeeklySchedule::add_byes() {
  return byes_.Add();
}
inline void WeeklySchedule::add_byes(const ::std::string& value) {
  byes_.Add()->assign(value);
}
inline void WeeklySchedule::add_byes(const char* value) {
  byes_.Add()->assign(value);
}
inline void WeeklySchedule::add_byes(const char* value, size_t size) {
  byes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WeeklySchedule::byes() const {
  return byes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WeeklySchedule::mutable_byes() {
  return &byes_;
}

// -------------------------------------------------------------------

// Kstats

// optional int32 pa = 10;
inline bool Kstats::has_pa() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Kstats::set_has_pa() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Kstats::clear_has_pa() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Kstats::clear_pa() {
  pa_ = 0;
  clear_has_pa();
}
inline ::google::protobuf::int32 Kstats::pa() const {
  return pa_;
}
inline void Kstats::set_pa(::google::protobuf::int32 value) {
  set_has_pa();
  pa_ = value;
}

// repeated int32 fg = 20;
inline int Kstats::fg_size() const {
  return fg_.size();
}
inline void Kstats::clear_fg() {
  fg_.Clear();
}
inline ::google::protobuf::int32 Kstats::fg(int index) const {
  return fg_.Get(index);
}
inline void Kstats::set_fg(int index, ::google::protobuf::int32 value) {
  fg_.Set(index, value);
}
inline void Kstats::add_fg(::google::protobuf::int32 value) {
  fg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Kstats::fg() const {
  return fg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Kstats::mutable_fg() {
  return &fg_;
}

// -------------------------------------------------------------------

// Dstats

// optional int32 twopt = 100;
inline bool Dstats::has_twopt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Dstats::set_has_twopt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Dstats::clear_has_twopt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Dstats::clear_twopt() {
  twopt_ = 0;
  clear_has_twopt();
}
inline ::google::protobuf::int32 Dstats::twopt() const {
  return twopt_;
}
inline void Dstats::set_twopt(::google::protobuf::int32 value) {
  set_has_twopt();
  twopt_ = value;
}

// optional int32 onept = 110;
inline bool Dstats::has_onept() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Dstats::set_has_onept() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Dstats::clear_has_onept() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Dstats::clear_onept() {
  onept_ = 0;
  clear_has_onept();
}
inline ::google::protobuf::int32 Dstats::onept() const {
  return onept_;
}
inline void Dstats::set_onept(::google::protobuf::int32 value) {
  set_has_onept();
  onept_ = value;
}

// optional int32 deftd = 120;
inline bool Dstats::has_deftd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Dstats::set_has_deftd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Dstats::clear_has_deftd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Dstats::clear_deftd() {
  deftd_ = 0;
  clear_has_deftd();
}
inline ::google::protobuf::int32 Dstats::deftd() const {
  return deftd_;
}
inline void Dstats::set_deftd(::google::protobuf::int32 value) {
  set_has_deftd();
  deftd_ = value;
}

// optional int32 sfty = 130;
inline bool Dstats::has_sfty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Dstats::set_has_sfty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Dstats::clear_has_sfty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Dstats::clear_sfty() {
  sfty_ = 0;
  clear_has_sfty();
}
inline ::google::protobuf::int32 Dstats::sfty() const {
  return sfty_;
}
inline void Dstats::set_sfty(::google::protobuf::int32 value) {
  set_has_sfty();
  sfty_ = value;
}

// optional int32 turnovers = 140;
inline bool Dstats::has_turnovers() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Dstats::set_has_turnovers() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Dstats::clear_has_turnovers() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Dstats::clear_turnovers() {
  turnovers_ = 0;
  clear_has_turnovers();
}
inline ::google::protobuf::int32 Dstats::turnovers() const {
  return turnovers_;
}
inline void Dstats::set_turnovers(::google::protobuf::int32 value) {
  set_has_turnovers();
  turnovers_ = value;
}

// optional int32 sacks = 150;
inline bool Dstats::has_sacks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Dstats::set_has_sacks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Dstats::clear_has_sacks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Dstats::clear_sacks() {
  sacks_ = 0;
  clear_has_sacks();
}
inline ::google::protobuf::int32 Dstats::sacks() const {
  return sacks_;
}
inline void Dstats::set_sacks(::google::protobuf::int32 value) {
  set_has_sacks();
  sacks_ = value;
}

// optional int32 ptsa = 160;
inline bool Dstats::has_ptsa() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Dstats::set_has_ptsa() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Dstats::clear_has_ptsa() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Dstats::clear_ptsa() {
  ptsa_ = 0;
  clear_has_ptsa();
}
inline ::google::protobuf::int32 Dstats::ptsa() const {
  return ptsa_;
}
inline void Dstats::set_ptsa(::google::protobuf::int32 value) {
  set_has_ptsa();
  ptsa_ = value;
}

// -------------------------------------------------------------------

// Ostats

// optional int32 passyds = 10;
inline bool Ostats::has_passyds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ostats::set_has_passyds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ostats::clear_has_passyds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ostats::clear_passyds() {
  passyds_ = 0;
  clear_has_passyds();
}
inline ::google::protobuf::int32 Ostats::passyds() const {
  return passyds_;
}
inline void Ostats::set_passyds(::google::protobuf::int32 value) {
  set_has_passyds();
  passyds_ = value;
}

// optional int32 passtd = 20;
inline bool Ostats::has_passtd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ostats::set_has_passtd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ostats::clear_has_passtd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ostats::clear_passtd() {
  passtd_ = 0;
  clear_has_passtd();
}
inline ::google::protobuf::int32 Ostats::passtd() const {
  return passtd_;
}
inline void Ostats::set_passtd(::google::protobuf::int32 value) {
  set_has_passtd();
  passtd_ = value;
}

// optional int32 rushyds = 30;
inline bool Ostats::has_rushyds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ostats::set_has_rushyds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ostats::clear_has_rushyds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ostats::clear_rushyds() {
  rushyds_ = 0;
  clear_has_rushyds();
}
inline ::google::protobuf::int32 Ostats::rushyds() const {
  return rushyds_;
}
inline void Ostats::set_rushyds(::google::protobuf::int32 value) {
  set_has_rushyds();
  rushyds_ = value;
}

// optional int32 rushtd = 40;
inline bool Ostats::has_rushtd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ostats::set_has_rushtd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ostats::clear_has_rushtd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ostats::clear_rushtd() {
  rushtd_ = 0;
  clear_has_rushtd();
}
inline ::google::protobuf::int32 Ostats::rushtd() const {
  return rushtd_;
}
inline void Ostats::set_rushtd(::google::protobuf::int32 value) {
  set_has_rushtd();
  rushtd_ = value;
}

// optional int32 recyds = 50;
inline bool Ostats::has_recyds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ostats::set_has_recyds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ostats::clear_has_recyds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ostats::clear_recyds() {
  recyds_ = 0;
  clear_has_recyds();
}
inline ::google::protobuf::int32 Ostats::recyds() const {
  return recyds_;
}
inline void Ostats::set_recyds(::google::protobuf::int32 value) {
  set_has_recyds();
  recyds_ = value;
}

// optional int32 rectd = 60;
inline bool Ostats::has_rectd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ostats::set_has_rectd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ostats::clear_has_rectd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ostats::clear_rectd() {
  rectd_ = 0;
  clear_has_rectd();
}
inline ::google::protobuf::int32 Ostats::rectd() const {
  return rectd_;
}
inline void Ostats::set_rectd(::google::protobuf::int32 value) {
  set_has_rectd();
  rectd_ = value;
}

// optional int32 rec = 70;
inline bool Ostats::has_rec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ostats::set_has_rec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ostats::clear_has_rec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ostats::clear_rec() {
  rec_ = 0;
  clear_has_rec();
}
inline ::google::protobuf::int32 Ostats::rec() const {
  return rec_;
}
inline void Ostats::set_rec(::google::protobuf::int32 value) {
  set_has_rec();
  rec_ = value;
}

// optional int32 pint = 80;
inline bool Ostats::has_pint() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ostats::set_has_pint() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ostats::clear_has_pint() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ostats::clear_pint() {
  pint_ = 0;
  clear_has_pint();
}
inline ::google::protobuf::int32 Ostats::pint() const {
  return pint_;
}
inline void Ostats::set_pint(::google::protobuf::int32 value) {
  set_has_pint();
  pint_ = value;
}

// optional int32 fumble = 90;
inline bool Ostats::has_fumble() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ostats::set_has_fumble() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ostats::clear_has_fumble() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ostats::clear_fumble() {
  fumble_ = 0;
  clear_has_fumble();
}
inline ::google::protobuf::int32 Ostats::fumble() const {
  return fumble_;
}
inline void Ostats::set_fumble(::google::protobuf::int32 value) {
  set_has_fumble();
  fumble_ = value;
}

// optional int32 twopt = 100;
inline bool Ostats::has_twopt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ostats::set_has_twopt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ostats::clear_has_twopt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ostats::clear_twopt() {
  twopt_ = 0;
  clear_has_twopt();
}
inline ::google::protobuf::int32 Ostats::twopt() const {
  return twopt_;
}
inline void Ostats::set_twopt(::google::protobuf::int32 value) {
  set_has_twopt();
  twopt_ = value;
}

// optional int32 onept = 110;
inline bool Ostats::has_onept() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ostats::set_has_onept() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ostats::clear_has_onept() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ostats::clear_onept() {
  onept_ = 0;
  clear_has_onept();
}
inline ::google::protobuf::int32 Ostats::onept() const {
  return onept_;
}
inline void Ostats::set_onept(::google::protobuf::int32 value) {
  set_has_onept();
  onept_ = value;
}

// -------------------------------------------------------------------

// Stats

// optional .fantasybit.Ostats ostats = 10;
inline bool Stats::has_ostats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stats::set_has_ostats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stats::clear_has_ostats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stats::clear_ostats() {
  if (ostats_ != NULL) ostats_->::fantasybit::Ostats::Clear();
  clear_has_ostats();
}
inline const ::fantasybit::Ostats& Stats::ostats() const {
  return ostats_ != NULL ? *ostats_ : *default_instance_->ostats_;
}
inline ::fantasybit::Ostats* Stats::mutable_ostats() {
  set_has_ostats();
  if (ostats_ == NULL) ostats_ = new ::fantasybit::Ostats;
  return ostats_;
}
inline ::fantasybit::Ostats* Stats::release_ostats() {
  clear_has_ostats();
  ::fantasybit::Ostats* temp = ostats_;
  ostats_ = NULL;
  return temp;
}
inline void Stats::set_allocated_ostats(::fantasybit::Ostats* ostats) {
  delete ostats_;
  ostats_ = ostats;
  if (ostats) {
    set_has_ostats();
  } else {
    clear_has_ostats();
  }
}

// optional .fantasybit.Dstats dstats = 20;
inline bool Stats::has_dstats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stats::set_has_dstats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stats::clear_has_dstats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stats::clear_dstats() {
  if (dstats_ != NULL) dstats_->::fantasybit::Dstats::Clear();
  clear_has_dstats();
}
inline const ::fantasybit::Dstats& Stats::dstats() const {
  return dstats_ != NULL ? *dstats_ : *default_instance_->dstats_;
}
inline ::fantasybit::Dstats* Stats::mutable_dstats() {
  set_has_dstats();
  if (dstats_ == NULL) dstats_ = new ::fantasybit::Dstats;
  return dstats_;
}
inline ::fantasybit::Dstats* Stats::release_dstats() {
  clear_has_dstats();
  ::fantasybit::Dstats* temp = dstats_;
  dstats_ = NULL;
  return temp;
}
inline void Stats::set_allocated_dstats(::fantasybit::Dstats* dstats) {
  delete dstats_;
  dstats_ = dstats;
  if (dstats) {
    set_has_dstats();
  } else {
    clear_has_dstats();
  }
}

// optional .fantasybit.Kstats kstats = 30;
inline bool Stats::has_kstats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stats::set_has_kstats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stats::clear_has_kstats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stats::clear_kstats() {
  if (kstats_ != NULL) kstats_->::fantasybit::Kstats::Clear();
  clear_has_kstats();
}
inline const ::fantasybit::Kstats& Stats::kstats() const {
  return kstats_ != NULL ? *kstats_ : *default_instance_->kstats_;
}
inline ::fantasybit::Kstats* Stats::mutable_kstats() {
  set_has_kstats();
  if (kstats_ == NULL) kstats_ = new ::fantasybit::Kstats;
  return kstats_;
}
inline ::fantasybit::Kstats* Stats::release_kstats() {
  clear_has_kstats();
  ::fantasybit::Kstats* temp = kstats_;
  kstats_ = NULL;
  return temp;
}
inline void Stats::set_allocated_kstats(::fantasybit::Kstats* kstats) {
  delete kstats_;
  kstats_ = kstats;
  if (kstats) {
    set_has_kstats();
  } else {
    clear_has_kstats();
  }
}

// -------------------------------------------------------------------

// PlayerResult

// optional string playerid = 20;
inline bool PlayerResult::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResult::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResult::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResult::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerResult::playerid() const {
  return *playerid_;
}
inline void PlayerResult::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerResult::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerResult::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResult::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerResult::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResult::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float result = 40;
inline bool PlayerResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResult::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline float PlayerResult::result() const {
  return result_;
}
inline void PlayerResult::set_result(float value) {
  set_has_result();
  result_ = value;
}

// optional .fantasybit.Stats stats = 50;
inline bool PlayerResult::has_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerResult::set_has_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerResult::clear_has_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerResult::clear_stats() {
  if (stats_ != NULL) stats_->::fantasybit::Stats::Clear();
  clear_has_stats();
}
inline const ::fantasybit::Stats& PlayerResult::stats() const {
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::fantasybit::Stats* PlayerResult::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::fantasybit::Stats;
  return stats_;
}
inline ::fantasybit::Stats* PlayerResult::release_stats() {
  clear_has_stats();
  ::fantasybit::Stats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void PlayerResult::set_allocated_stats(::fantasybit::Stats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// repeated .fantasybit.FantasyBitAward fantaybitaward = 60;
inline int PlayerResult::fantaybitaward_size() const {
  return fantaybitaward_.size();
}
inline void PlayerResult::clear_fantaybitaward() {
  fantaybitaward_.Clear();
}
inline const ::fantasybit::FantasyBitAward& PlayerResult::fantaybitaward(int index) const {
  return fantaybitaward_.Get(index);
}
inline ::fantasybit::FantasyBitAward* PlayerResult::mutable_fantaybitaward(int index) {
  return fantaybitaward_.Mutable(index);
}
inline ::fantasybit::FantasyBitAward* PlayerResult::add_fantaybitaward() {
  return fantaybitaward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitAward >&
PlayerResult::fantaybitaward() const {
  return fantaybitaward_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitAward >*
PlayerResult::mutable_fantaybitaward() {
  return &fantaybitaward_;
}

// repeated .fantasybit.FantasyBitPnl fantasybitpnl = 70;
inline int PlayerResult::fantasybitpnl_size() const {
  return fantasybitpnl_.size();
}
inline void PlayerResult::clear_fantasybitpnl() {
  fantasybitpnl_.Clear();
}
inline const ::fantasybit::FantasyBitPnl& PlayerResult::fantasybitpnl(int index) const {
  return fantasybitpnl_.Get(index);
}
inline ::fantasybit::FantasyBitPnl* PlayerResult::mutable_fantasybitpnl(int index) {
  return fantasybitpnl_.Mutable(index);
}
inline ::fantasybit::FantasyBitPnl* PlayerResult::add_fantasybitpnl() {
  return fantasybitpnl_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitPnl >&
PlayerResult::fantasybitpnl() const {
  return fantasybitpnl_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyBitPnl >*
PlayerResult::mutable_fantasybitpnl() {
  return &fantasybitpnl_;
}

// -------------------------------------------------------------------

// GameResult

// optional string gameid = 1;
inline bool GameResult::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameResult::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameResult::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameResult::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& GameResult::gameid() const {
  return *gameid_;
}
inline void GameResult::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameResult::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameResult::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResult::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* GameResult::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResult::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .fantasybit.PlayerResult home_result = 10;
inline int GameResult::home_result_size() const {
  return home_result_.size();
}
inline void GameResult::clear_home_result() {
  home_result_.Clear();
}
inline const ::fantasybit::PlayerResult& GameResult::home_result(int index) const {
  return home_result_.Get(index);
}
inline ::fantasybit::PlayerResult* GameResult::mutable_home_result(int index) {
  return home_result_.Mutable(index);
}
inline ::fantasybit::PlayerResult* GameResult::add_home_result() {
  return home_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >&
GameResult::home_result() const {
  return home_result_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >*
GameResult::mutable_home_result() {
  return &home_result_;
}

// repeated .fantasybit.PlayerResult away_result = 20;
inline int GameResult::away_result_size() const {
  return away_result_.size();
}
inline void GameResult::clear_away_result() {
  away_result_.Clear();
}
inline const ::fantasybit::PlayerResult& GameResult::away_result(int index) const {
  return away_result_.Get(index);
}
inline ::fantasybit::PlayerResult* GameResult::mutable_away_result(int index) {
  return away_result_.Mutable(index);
}
inline ::fantasybit::PlayerResult* GameResult::add_away_result() {
  return away_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >&
GameResult::away_result() const {
  return away_result_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerResult >*
GameResult::mutable_away_result() {
  return &away_result_;
}

// optional uint32 kickofftime = 30;
inline bool GameResult::has_kickofftime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameResult::set_has_kickofftime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameResult::clear_has_kickofftime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameResult::clear_kickofftime() {
  kickofftime_ = 0u;
  clear_has_kickofftime();
}
inline ::google::protobuf::uint32 GameResult::kickofftime() const {
  return kickofftime_;
}
inline void GameResult::set_kickofftime(::google::protobuf::uint32 value) {
  set_has_kickofftime();
  kickofftime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StaticData_2eproto__INCLUDED
